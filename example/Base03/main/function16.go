package main

/*
闭包（closure）是在其词法上下文中引用了自由变量的函数，或者说是函数和其引用的环境的组合体。
注意：
闭包让我们不用传递参数就可读取或修改环境状态，当然也要为此付出额外代价。
对于性能要求较高的场合，须慎重使用。
 */
func main() {

	/*
	test返回的匿名函数会引用上下文环境变量 x。
	当该函数在 main 中执行时，它依然可正确读取 x 的值，这种现象就称作闭包。
	 */
	//f := test16(10)
	//f()

	/*
	通过输出指针，我们注意到闭包直接引用了原环境变量。
	分析汇编代码，可以看到返回的不仅仅是匿名函数，还包括所引用的环境变量指针。
	所以说，闭包是函数和引用环境的组合体更加确切。
	本质上返回的是一个 funcval 结构，可在runtime/runtime2.go。
	 */
	//df := div16(0x100)
	//df()

	/*
	正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，
	甚至被分配到堆内存。另外，还有所谓“延迟求值”的特性。
	 */
	/*for _, f := range demo16() {
		//迭代执行所有匿名函数
		//0xc042038000 2
		//0xc042038000 2
		f()
	}*/

	/*
	多个匿名函数引用同一环境变量，也会让事情变得更加复杂。
	任何的修改行为都会影响其他函数取值，在并发模式下可能需要做同步处理。
	 */
	a, b := show16(100)
	a()//100
	b()//110
}

/*
test返回的匿名函数会引用上下文环境变量 x。
当该函数在 main 中执行时，它依然可正确读取 x 的值，这种现象就称作闭包。
 */
func test16(x int) func() {
	return func() {
		println(x)
	}
}

/*
通过输出指针，我们注意到闭包直接引用了原环境变量。
分析汇编代码，可以看到返回的不仅仅是匿名函数，还包括所引用的环境变量指针。
所以说，闭包是函数和引用环境的组合体更加确切。
本质上返回的是一个 funcval 结构，可在runtime/runtime2.go。
 */
func div16(x int) func() {

	println(&x)//0xc0420040b0

	return func() {
		println(&x, x)//0xc0420040b0 256
	}

}

/*
正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，
甚至被分配到堆内存。另外，还有所谓“延迟求值”的特性。
 */
func demo16() []func() {

	var s []func()

	/*
	输出结果示例：
	0xc042038000 2
	0xc042038000 2
	对这个输出结果不必惊讶。很简单，for 循环复用局部变量 i，
	那么每次添加的匿名函数引用的自然是同一变量。
	添加操作仅仅是将匿名函数放入列表，并未执行。
	因此，当 main 执行这些函数时，它们读取的是环境变量 i 最后一次循环时的值。
	此时 i 最后一次循环的值为 2。
	****************************************************************************
	要想得到每次不同的值，解决办法就是每次不同的环境变量或传参复制，让各自闭包环境各不相同。
	for i := 0; i < 2; i++ {
		x := i	//x 每次循环都重新定义
		s = append(s, func(){
			println(&x, x)
		})
	}
	输出结果示例：
	0xc042038066 0
	0xc037028095 1
	 */
	for i := 0; i < 2; i++ {
		s = append(s, func() {
			//将多个匿名函数添加到列表
			println(&i, i)
		})
	}

	return s//返回匿名函数列表

}

/*
多个匿名函数引用同一环境变量，也会让事情变得更加复杂。
任何的修改行为都会影响其他函数取值，在并发模式下可能需要做同步处理。
 */
func show16(x int) (func(), func()) {
	//返回多个匿名函数
	return func() {
		println(x)
		x += 10//修改环境变量
	}, func() {
		println(x)//显示环境变量
	}
}
